<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D/3D Map - Taiwan with GPX and Contour Lines</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/openlayers/9.2.4/ol.css">
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.95/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1500px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 300;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .upload-button, .save-route-button, .clear-routes-button, 
        .reset-view-button, .switch-to-3d-button, .switch-to-2d-button,.tracking-button {
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-button {
            background: linear-gradient(135deg, #4fd1c5, #319795);
        }

        .save-route-button {
            background: linear-gradient(135deg, #f6ad55, #ed8936);
        }

        .clear-routes-button {
            background: linear-gradient(135deg, #f56565, #e53e3e);
        }

        .reset-view-button {
            background: linear-gradient(135deg, #9f7aea, #805ad5);
        }

        .switch-to-3d-button {
            background: linear-gradient(135deg, #4299e1, #3182ce);
        }

        .switch-to-2d-button {
            background: linear-gradient(135deg, #48bb78, #38a169);
            display: none; /* Hidden by default */
        }
        .tracking-button {
            background: linear-gradient(135deg, #4299e1, #3182ce);
        }
        .upload-button:hover, .save-route-button:hover, 
        .clear-routes-button:hover, .reset-view-button:hover,
        .switch-to-3d-button:hover, .switch-to-2d-button:hover, .tracking-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .map-container {
            height: 700px;
            position: relative;
        }

        #map2d {
            width: 100%;
            height: 100%;
        }

        #map3d {
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
        }

        .route-selector {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 1000;
            display: none;
        }

        .route-selector select {
            padding: 5px;
            border-radius: 4px;
            border: none;
            margin-left: 10px;
        }

        #fileInput {
            display: none;
        }

        /* Elevation profile modal styles */
        .elevation-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .elevation-content {
            background-color: white;
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .elevation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .elevation-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #7f8c8d;
        }

        .elevation-chart-container {
            height: 300px;
            width: 100%;
            position: relative;
        }

        .elevation-stats {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ecf0f1;
        }

        .stat-item {
            text-align: center;
            flex: 1 1 45%; /* Two columns on larger screens, one on smaller */
            padding: 5px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
        }
        
        /* Waypoint popup styles */
        .ol-popup {
            position: absolute;
            background-color: white;
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #cccccc;
            bottom: 12px;
            left: -50px;
            min-width: 200px;
            font-family: Arial, sans-serif;
            color: #333;
        }
        .ol-popup:after, .ol-popup:before {
            top: 100%;
            border: solid transparent;
            content: " ";
            height: 0;
            width: 0;
            position: absolute;
            pointer-events: none;
        }
        .ol-popup:after {
            border-top-color: white;
            border-width: 10px;
            left: 48px;
            margin-left: -10px;
        }
        .ol-popup:before {
            border-top-color: #cccccc;
            border-width: 11px;
            left: 48px;
            margin-left: -11px;
        }
        .ol-popup-closer {
            text-decoration: none;
            position: absolute;
            top: 2px;
            right: 8px;
            font-size: 1.2em;
            color: #888;
        }
        .ol-popup-closer:hover {
            color: #333;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            .header-controls {
                flex-direction: column;
                width: 100%;
            }
            .upload-button, .save-route-button, 
            .clear-routes-button, .reset-view-button,
            .switch-to-3d-button, .switch-to-2d-button ,.tracking-button{
                width: 100%;
            }
            
            .elevation-content {
                width: 95%;
                padding: 10px;
            }
            
            .elevation-chart-container {
                height: 200px;
            }

            .elevation-stats {
                flex-direction: column;
            }
            .stat-item {
                flex: 1 1 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>MOUNTAIN MAP</h1>
            <div class="header-controls">
                <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                    Upload GPX
                </button>
                <button class="save-route-button" onclick="showRouteSelector()" id="saveRouteBtn">
                    Saved Routes
                </button>
                <button class="clear-routes-button" onclick="clearAllRoutes()">
                    Clear Routes
                </button>
                <button class="reset-view-button" onclick="resetToTaiwanView()">
                    Home
                </button>
                  <button class="tracking-button" id="startTrackingBtn" onclick="startTracking()">
                Start Tracking
            </button>
            <button class="tracking-button" id="stopTrackingBtn" onclick="stopTracking()" style="display: none;">
                Stop Tracking
            </button>
                <button class="switch-to-3d-button" id="switchTo3D" onclick="switchTo3D()">
                    3D View
                </button>
                <button class="switch-to-2d-button" id="switchTo2D" onclick="switchTo2D()">
                    2D View
                </button>
                <input type="file" id="fileInput" accept=".gpx,.xml" onchange="handleGPXUpload(event)">
            </div>
        </div>

        <div class="map-container">
            <div id="map2d"></div>
            <div id="map3d"></div>
            <div class="route-selector" id="routeSelector">
                Select Route: 
                <select id="routeSelect" onchange="zoomToRoute()">
                    <option value="">-- Select a route --</option>
                </select>
            </div>
            <div id="popup" class="ol-popup">
                <a href="#" id="popup-closer" class="ol-popup-closer"></a>
                <div id="popup-content"></div>
            </div>
        </div>
    </div>

    <div class="elevation-modal" id="elevationModal">
        <div class="elevation-content">
            <div class="elevation-header">
                <div class="elevation-title" id="elevationTitle">Elevation Profile</div>
                <button class="close-button" onclick="closeElevationModal()">&times;</button>
            </div>
            <div class="elevation-chart-container">
                <canvas id="elevationChart"></canvas>
            </div>
            <div class="elevation-stats">
                <div class="stat-item">
                    <div class="stat-label">Distance</div>
                    <div class="stat-value" id="totalDistance">0 km</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Min Elevation</div>
                    <div class="stat-value" id="minElevation">0 m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Max Elevation</div>
                    <div class="stat-value" id="maxElevation">0 m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Elevation Gain</div>
                    <div class="stat-value" id="elevationGain">0 m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Moving Time</div>
                    <div class="stat-value" id="totalMovingTime">00:00:00</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/openlayers/9.2.4/dist/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.95/Build/Cesium/Cesium.js"></script>
    <script>
        let map2d;
        let map3d;
        let vectorLayer2D;
        let savedRoutes = [];
        let routeSelect = document.getElementById('routeSelect');
        let routeSelector = document.getElementById('routeSelector');
        let contourLayer;
        let elevationChart;
        let currentElevationData = [];
        let cesiumEntities = [];
        let currentViewMode = '2d'; // '2d' or '3d'
        
        // Waypoint popup elements
        const popup = new ol.Overlay({
            element: document.getElementById('popup'),
            autoPan: {
                animation: {
                    duration: 250,
                },
            },
        });
        const popupCloser = document.getElementById('popup-closer');
        const popupContent = document.getElementById('popup-content');

        // Taiwan coordinates and view settings
        const TAIWAN_CENTER = [120.9605, 23.6978];
        const TAIWAN_ZOOM = 8;
        const TAIWAN_3D_VIEW = {
            destination: Cesium.Cartesian3.fromDegrees(120.9605, 23.6978, 2000000),
            orientation: {
                heading: 0.0,
                pitch: -Cesium.Math.PI_OVER_TWO,
                roll: 0.0
            }
        };

        // Initialize 2D Map (OpenLayers)
        function init2DMap() {
            // Create vector layer for GPX routes and Waypoints
            vectorLayer2D = new ol.layer.Vector({
                source: new ol.source.Vector(),
                style: function(feature) {
                    if (feature.getGeometry().getType() === 'LineString') {
                        // Check if it's a tracking line
                        if (feature.get('isTracking')) {
                            return new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: '#4299e1',
                                    width: 4,
                                    lineDash: [10, 5]
                                })
                            });
                        }
                        // Default style for saved GPX routes
                        return new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: '#ff5722',
                                width: 3
                            })
                        });
                    } else if (feature.getGeometry().getType() === 'Point') {
                        // Style for Waypoints
                        const zoom = map2d.getView().getZoom();
                        if (zoom < 12) { // Hide points when zoomed out (adjust zoom level as needed)
                            return null;
                        }
                        return new ol.style.Style({
                            image: new ol.style.Circle({
                                radius: 7,
                                fill: new ol.style.Fill({
                                    color: 'rgba(255, 0, 0, 0.7)'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: 'rgba(255, 0, 0, 1)',
                                    width: 2
                                })
                            }),
                            text: new ol.style.Text({
                                font: '12px Calibri,sans-serif',
                                fill: new ol.style.Fill({ color: '#000' }),
                                stroke: new ol.style.Stroke({
                                    color: '#fff', width: 3
                                }),
                                offsetY: -15, // Offset text above the marker
                                text: feature.get('name') || '' // Display waypoint name
                            })
                        });
                    }
                }
            });

            // Create contour lines layer (100m interval)
            contourLayer = new ol.layer.Vector({
                source: new ol.source.Vector({
                    url: 'https://tiles.arcgis.com/tiles/nGt4QxSblgDfeJn9/arcgis/rest/services/World_Contour/VectorTileServer/tile/{z}/{y}/{x}.pbf',
                    format: new ol.format.MVT(),
                    attributions: 'Contour lines: &copy; <a href="https://www.arcgis.com/home/item.html?id=1e126e7520f9466c9ca28b8f28b5e500">Esri</a>'
                }),
                style: createContourStyle,
                minResolution: 0, // Show at all zoom levels
                maxResolution: 100 // Hide when zoomed out too far
            });

            map2d = new ol.Map({
                target: 'map2d',
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.OSM()
                    }),
                    contourLayer,
                    vectorLayer2D
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat(TAIWAN_CENTER),
                    zoom: TAIWAN_ZOOM
                }),
                overlays: [popup] // Add the popup overlay
            });

            // Add click event listener to the map
            map2d.on('click', function(evt) {
                let featureClicked = false;
                map2d.forEachFeatureAtPixel(evt.pixel, function(feature) {
                    if (feature.getGeometry().getType() === 'LineString') {
                        const coords = feature.getGeometry().getCoordinates();
                        const lonLatCoords = coords.map(coord => ol.proj.toLonLat(coord));
                        let routeMovingTime = 0;

                        // Check if it's a saved route
                        const routeName = feature.get('name');
                        const isTrackingFeature = feature.get('isTracking'); // Check custom property for tracking
                        
                        if (isTrackingFeature && currentTrack.coordinates.length > 0) {
                            // If it's the current tracking line, use its data
                            routeMovingTime = calculateMovingTime(currentTrack.timestamps);
                            getElevationProfile(lonLatCoords, routeMovingTime);
                        } else if (routeName) { // If it's a saved route
                            const route = savedRoutes.find(r => r.name === routeName && 
                                                                JSON.stringify(r.coordinates.map(c => ol.proj.fromLonLat(c))) === JSON.stringify(coords));
                            if (route) {
                                routeMovingTime = route.movingTime;
                                getElevationProfile(lonLatCoords, routeMovingTime); 
                            } else {
                                getElevationProfile(lonLatCoords); // Fallback if route not fully matched
                            }
                        } else {
                             getElevationProfile(lonLatCoords); // For any other line (e.g., if name is missing but it's a line)
                        }
                        
                        featureClicked = true;
                    } else if (feature.getGeometry().getType() === 'Point') {
                        // Handle waypoint click
                        const coordinate = feature.getGeometry().getCoordinates();
                        const name = feature.get('name') || 'Unnamed Waypoint';
                        const description = feature.get('desc') || 'No description available.';

                        popupContent.innerHTML = `<b>${name}</b><p>${description}</p>`;
                        popup.setPosition(coordinate);
                        featureClicked = true;
                    }
                });

                if (!featureClicked) {
                    popup.setPosition(undefined); // Hide popup if no feature is clicked
                    popupCloser.blur();
                }
            });

            // Close popup when closer is clicked
            popupCloser.onclick = function() {
                popup.setPosition(undefined);
                popupCloser.blur();
                return false;
            };

            // Re-render layer on zoom to apply waypoint visibility logic
            map2d.getView().on('change:resolution', function() {
                vectorLayer2D.changed();
            });
        }

        // Initialize 3D Map (Cesium)
        function init3DMap() {
            // Your Cesium ion access token (replace with your own)
            Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzMTI4YjE3OC1iNmVlLTRmMjQtODdhYS1kN2FiMzhkZDY1MjEiLCJpZCI6Mjk1ODg3LCJpYXQiOjE3NDUyOTE1NjJ9.ss2YK3CdkwaCvtS0O-AskkrH5yf0OunQnQkYaVysuwM';
            
            // Initialize the Cesium Viewer
            map3d = new Cesium.Viewer('map3d', {
                terrainProvider: Cesium.createWorldTerrain(),
                baseLayerPicker: false,
                sceneModePicker: false,
                homeButton: false,
                geocoder: false,
                navigationHelpButton: false,
                animation: false,
                timeline: false,
                fullscreenButton: false,
                infoBox: false,
                selectionIndicator: false,
            });

            // Set initial view to Taiwan
            map3d.camera.flyTo(TAIWAN_3D_VIEW);

            // Enable lighting effects
            map3d.scene.globe.enableLighting = true;

            // Add click handler for routes
            map3d.screenSpaceEventHandler.setInputAction(function(movement) {
                const pickedObject = map3d.scene.pick(movement.position);
                if (Cesium.defined(pickedObject) && pickedObject.id) {
                    if (pickedObject.id.routeId !== undefined) {
                        const route = savedRoutes[pickedObject.id.routeId];
                        if (route) {
                            getElevationProfile(route.coordinates, route.movingTime); // Pass movingTime for 3D
                        }
                    } else if (pickedObject.id === 'currentTrackingLine' && currentTrack.coordinates.length > 0) {
                        // Handle click on current tracking line in 3D
                        const movingTime = calculateMovingTime(currentTrack.timestamps);
                        getElevationProfile(currentTrack.coordinates, movingTime);
                    }
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }

        // Style function for contour lines
        function createContourStyle(feature) {
            const elevation = feature.get('ELEV');
            const isIndexContour = elevation % 500 === 0; // Thicker lines for 500m intervals
            
            return new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: isIndexContour ? 'rgba(0, 0, 255, 0.8)' : 'rgba(0, 0, 255, 0.5)',
                    width: isIndexContour ? 2 : 1
                })
            });
        }

        // Reset view to Taiwan
        function resetToTaiwanView() {
            if (currentViewMode === '2d' && map2d) {
                const taiwanLocation = ol.proj.fromLonLat(TAIWAN_CENTER);
                map2d.getView().animate({
                    center: taiwanLocation,
                    zoom: TAIWAN_ZOOM,
                    duration: 1000
                });
            } else if (currentViewMode === '3d' && map3d) {
                map3d.camera.flyTo(TAIWAN_3D_VIEW);
            }
        }

        // Switch to 3D view
        function switchTo3D() {
            if (currentViewMode === '3d') return;
            
            // Initialize 3D map if not already done
            if (!map3d) {
                init3DMap();
            }
            
            // Hide 2D map and show 3D map
            document.getElementById('map2d').style.display = 'none';
            document.getElementById('map3d').style.display = 'block';
            
            // Update UI buttons
            document.getElementById('switchTo3D').style.display = 'none';
            document.getElementById('switchTo2D').style.display = 'block';
            
            currentViewMode = '3d';
            
            // Add all saved routes to 3D map
            update3DRoutes();
            updateTrackingDisplay(); // Also update the tracking display for 3D
            
            // Reset view to Taiwan
            resetToTaiwanView();
        }

        // Switch to 2D view
        function switchTo2D() {
            if (currentViewMode === '2d') return;
            
            // Hide 3D map and show 2D map
            document.getElementById('map3d').style.display = 'none';
            document.getElementById('map2d').style.display = 'block';
            
            // Update UI buttons
            document.getElementById('switchTo2D').style.display = 'none';
            document.getElementById('switchTo3D').style.display = 'block';
            
            currentViewMode = '2d';
            
            // Reset view to Taiwan
            resetToTaiwanView();
        }

        // Update 3D routes (add all saved routes to 3D map)
        function update3DRoutes() {
            if (!map3d) return;
            
            // Remove existing entities
            cesiumEntities.forEach(entity => {
                map3d.entities.remove(entity);
            });
            cesiumEntities = [];
            
            // Add all saved routes
            savedRoutes.forEach((route, index) => {
                const positions = Cesium.Cartesian3.fromDegreesArray(
                    route.coordinates.flat()
                );
                
                const routeEntity = map3d.entities.add({
                    name: route.name,
                    polyline: {
                        positions: positions,
                        width: 5,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.2,
                            color: Cesium.Color.ORANGE
                        }),
                        clampToGround: true
                    },
                    routeId: index // Custom property to identify the route
                });
                
                cesiumEntities.push(routeEntity);
            });
        }

        // Handle GPX file upload
        function handleGPXUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const gpxContent = e.target.result;
                const routeName = file.name.replace('.gpx', '').replace('.xml', '');
                
                // Parse GPX and add to saved routes and waypoints
                parseGPX(gpxContent, routeName);
                
                // Save to localStorage
                saveRoutesToStorage();
                
                // Add to route selector
                updateRouteSelector();
                
                // Show the route selector if it's hidden
                routeSelector.style.display = 'block';
                
                // Zoom to the newly added route
                zoomToRoute(savedRoutes.length - 1);
            };
            reader.readAsText(file);
        }

        // Parse GPX file and add to map
        function parseGPX(gpxContent, routeName) {
            try {
                // Parse XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(gpxContent, "text/xml");
                
                // Check for parsing errors
                const parserErrors = xmlDoc.getElementsByTagName("parsererror");
                if (parserErrors.length > 0) {
                    throw new Error("Invalid GPX file format");
                }

                // Extract coordinates and timestamps from GPX track points
                const trackPoints = xmlDoc.getElementsByTagName("trkpt");
                const coordinates = [];
                const timestamps = [];
                
                for (let i = 0; i < trackPoints.length; i++) {
                    const pt = trackPoints[i];
                    const lon = parseFloat(pt.getAttribute("lon"));
                    const lat = parseFloat(pt.getAttribute("lat"));
                    const timeElement = pt.getElementsByTagName('time')[0];
                    const time = timeElement ? new Date(timeElement.textContent) : null;
                    
                    // Skip invalid coordinates
                    if (isNaN(lon) || isNaN(lat)) continue;
                    
                    coordinates.push([lon, lat]);
                    if (time) {
                        timestamps.push(time);
                    }
                }
                
                let movingTime = 0;
                if (timestamps.length > 1) {
                    movingTime = calculateMovingTime(timestamps); // Use the unified function
                }

                // Save route data
                const routeIndex = savedRoutes.length;
                savedRoutes.push({
                    name: routeName,
                    coordinates: coordinates,
                    waypoints: [],
                    movingTime: movingTime // Store moving time
                });

                // Extract waypoints from GPX
                const waypoints = xmlDoc.getElementsByTagName("wpt");
                for (let i = 0; i < waypoints.length; i++) {
                    const wpt = waypoints[i];
                    const lon = parseFloat(wpt.getAttribute("lon"));
                    const lat = parseFloat(wpt.getAttribute("lat"));
                    const name = wpt.getElementsByTagName('name')[0]?.textContent || '';
                    const desc = wpt.getElementsByTagName('desc')[0]?.textContent || '';

                    if (!isNaN(lon) && !isNaN(lat)) {
                        const pointFeature = new ol.Feature({
                            geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
                            name: name,
                            desc: desc,
                            type: 'waypoint' // Custom property to identify as waypoint
                        });
                        vectorLayer2D.getSource().addFeature(pointFeature);
                        savedRoutes[routeIndex].waypoints.push({ lon, lat, name, desc });
                    }
                }
                
                // Add track to map if coordinates exist
                if (coordinates.length > 0) {
                    addRouteToMap(coordinates, routeName); // Pass routeName to addRouteToMap
                }
                
                return true;
            } catch (error) {
                alert("Error parsing GPX file: " + error.message);
                return false;
            }
        }

        // Calculate moving time from an array of timestamps (in seconds)
        function calculateMovingTime(timestamps) {
            let totalSeconds = 0;
            // Threshold for identifying pauses: 5 minutes (300 seconds)
            const pauseThresholdSeconds = 300; 

            for (let i = 1; i < timestamps.length; i++) {
                const diff = (timestamps[i].getTime() - timestamps[i-1].getTime()) / 1000; // Difference in seconds
                if (diff > 0 && diff < pauseThresholdSeconds) { 
                    totalSeconds += diff;
                }
            }
            return totalSeconds;
        }

        // Format seconds into HH:MM:SS
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = Math.floor(seconds % 60);

            const pad = (num) => num.toString().padStart(2, '0');
            return `${pad(hours)}:${pad(minutes)}:${pad(remainingSeconds)}`;
        }

        // Add route to map
        function addRouteToMap(coordinates, routeName, isTracking = false) {
            // Add to 2D map
            const lineString = new ol.geom.LineString(coordinates);
            lineString.transform('EPSG:4326', 'EPSG:3857');
            
            const feature = new ol.Feature({
                geometry: lineString,
                name: routeName,
                isTracking: isTracking // Set custom property
            });
            
            vectorLayer2D.getSource().addFeature(feature);
            
            // Add to 3D map if in 3D mode
            if (currentViewMode === '3d' && map3d) {
                update3DRoutes(); // This function will add saved routes. For tracking, updateTrackingDisplay is used.
            }
        }

        // Show route selector dropdown
        function showRouteSelector() {
            if (savedRoutes.length === 0) {
                alert("No routes available. Please upload a GPX file first.");
                return;
            }
            
            routeSelector.style.display = routeSelector.style.display === 'block' ? 'none' : 'block';
        }

        // Zoom to selected route
        function zoomToRoute(index) {
            if (index === undefined) {
                index = routeSelect.value;
                if (index === "") return;
            }
            
            const route = savedRoutes[index];
            if (!route) return;
            
            if (currentViewMode === '2d') {
                // Combine route coordinates and waypoint coordinates for extent calculation
                let allCoords = [...route.coordinates];
                route.waypoints.forEach(wp => allCoords.push([wp.lon, wp.lat]));

                if (allCoords.length === 0) {
                    resetToTaiwanView(); // Fallback if no coords found
                    return;
                }

                const extent = ol.extent.boundingExtent(
                    allCoords.map(coord => ol.proj.fromLonLat(coord))
                );
                
                // Add some padding
                ol.extent.scaleFromCenter(extent, 1.2);
                
                map2d.getView().fit(extent, {
                    padding: [50, 50, 50, 50],
                    duration: 1000
                });
            } else {
                // Fly to route in 3D
                const positions = Cesium.Cartesian3.fromDegreesArray(
                    route.coordinates.flat()
                );
                
                // Calculate bounding sphere
                const boundingSphere = Cesium.BoundingSphere.fromPoints(positions);
                
                // Fly to the route with some offset
                map3d.camera.flyTo({
                destination: Cesium.Cartesian3.fromElements(
                        boundingSphere.center.x-boundingSphere.radius * 3,
                        boundingSphere.center.y+boundingSphere.radius * 5.5,
                        boundingSphere.center.z -boundingSphere.radius * 4),
                orientation: {
                    heading: 0.0,
                    pitch: -0.5,
                    roll: 0.0
                },
        });
            }
        }

        // Save routes to localStorage
        function saveRoutesToStorage() {
            localStorage.setItem('savedRoutes', JSON.stringify(savedRoutes));
        }

        // Load routes from localStorage
        function loadSavedRoutes() {
            const storedRoutes = localStorage.getItem('savedRoutes');
            if (storedRoutes) {
                savedRoutes = JSON.parse(storedRoutes);
                
                // Clear existing routes and waypoints from map
                vectorLayer2D.getSource().clear();
                
                // Add all saved routes and their waypoints to map
                savedRoutes.forEach(route => {
                    if (route.coordinates && route.coordinates.length > 0) {
                        addRouteToMap(route.coordinates, route.name); // Pass name for saved routes
                    }
                    if (route.waypoints && route.waypoints.length > 0) {
                        route.waypoints.forEach(wp => {
                            const pointFeature = new ol.Feature({
                                geometry: new ol.geom.Point(ol.proj.fromLonLat([wp.lon, wp.lat])),
                                name: wp.name,
                                desc: wp.desc,
                                type: 'waypoint'
                            });
                            vectorLayer2D.getSource().addFeature(pointFeature);
                        });
                    }
                });
                
                // Update route selector
                updateRouteSelector();
                
                // Show selector if there are routes
                if (savedRoutes.length > 0) {
                    routeSelector.style.display = 'block';
                }
            }
        }

        // Update the route selector dropdown
        function updateRouteSelector() {
            // Clear existing options
            routeSelect.innerHTML = '<option value="">-- Select a route --</option>';
            
            // Add all saved routes
            savedRoutes.forEach((route, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = route.name;
                routeSelect.appendChild(option);
            });
        }

        // Clear all saved routes
        function clearAllRoutes() {
            if (savedRoutes.length === 0) {
                alert("No routes to clear.");
                return;
            }
            
            if (confirm("Are you sure you want to delete all saved routes?")) {
                // Clear from map
                vectorLayer2D.getSource().clear();
                
                // Clear from 3D map if active
                if (map3d) {
                    cesiumEntities.forEach(entity => {
                        map3d.entities.remove(entity);
                    });
                    cesiumEntities = [];
                }
                
                // Clear from memory and storage
                savedRoutes = [];
                localStorage.removeItem('savedRoutes');
                
                // Update UI
                routeSelect.innerHTML = '<option value="">-- Select a route --</option>';
                routeSelector.style.display = 'none';
                popup.setPosition(undefined); // Hide popup
            }
        }

        // Get elevation profile for a route
        async function getElevationProfile(coordinates, movingTime = 0) {
            // Show loading state
            document.getElementById('elevationTitle').textContent = "Loading elevation data...";
            document.getElementById('totalDistance').textContent = "Calculating...";
            document.getElementById('minElevation').textContent = "";
            document.getElementById('maxElevation').textContent = "";
            document.getElementById('elevationGain').textContent = "";
            
            // Conditionally show/hide moving time
            const totalMovingTimeElement = document.getElementById('totalMovingTime');
            const movingTimeStatItem = totalMovingTimeElement.parentElement; // Get the parent stat-item div

            if (movingTime > 0) {
                movingTimeStatItem.style.display = 'block'; // Show if movingTime is provided
                totalMovingTimeElement.textContent = "Calculating...";
            } else {
                movingTimeStatItem.style.display = 'none'; // Hide if no movingTime
            }

            // Open the modal
            const modal = document.getElementById('elevationModal');
            modal.style.display = 'flex';
            
            try {
                // Simplify the coordinates to reduce API calls
                const simplifiedCoords = simplifyCoordinates(coordinates, 0.0001);
                
                // Get elevations for each point
                const elevationData = await getElevations(simplifiedCoords);
                
                // Calculate distance between points
                const distances = calculateDistances(simplifiedCoords);
                
                // Calculate cumulative distance
                const cumulativeDistances = calculateCumulativeDistances(distances);
                
                // Calculate elevation gain
                const elevationGain = calculateElevationGain(elevationData);
                
                // Update the chart
                updateElevationChart(cumulativeDistances, elevationData);
                
                // Update stats
                document.getElementById('elevationTitle').textContent = "Elevation Profile";
                document.getElementById('totalDistance').textContent = (cumulativeDistances[cumulativeDistances.length - 1] / 1000).toFixed(2) + " km";
                document.getElementById('minElevation').textContent = Math.min(...elevationData) + " m";
                document.getElementById('maxElevation').textContent = Math.max(...elevationData) + " m";
                document.getElementById('elevationGain').textContent = elevationGain + " m";
                
                if (movingTime > 0) {
                    totalMovingTimeElement.textContent = formatTime(movingTime);
                } else {
                    totalMovingTimeElement.textContent = "N/A"; // Or leave empty
                }
                
                // Save current elevation data for chart reference
                currentElevationData = {
                    distances: cumulativeDistances,
                    elevations: elevationData
                };
                
            } catch (error) {
                console.error("Error getting elevation data:", error);
                document.getElementById('elevationTitle').textContent = "Error Loading Elevation Data";
                alert("Failed to load elevation data. Please try again.");
            }
        }

        // Simplify coordinates using Douglas-Peucker algorithm
        function simplifyCoordinates(coordinates, tolerance) {
            if (coordinates.length <= 2) return coordinates;
            
            // Find the point with the maximum distance
            let maxDist = 0;
            let maxIndex = 0;
            const start = coordinates[0];
            const end = coordinates[coordinates.length - 1];
            
            for (let i = 1; i < coordinates.length - 1; i++) {
                const dist = perpendicularDistance(coordinates[i], start, end);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxIndex = i;
                }
            }
            
            // If max distance is greater than tolerance, recursively simplify
            if (maxDist > tolerance) {
                const left = coordinates.slice(0, maxIndex + 1);
                const right = coordinates.slice(maxIndex);
                
                const simplifiedLeft = simplifyCoordinates(left, tolerance);
                const simplifiedRight = simplifyCoordinates(right, tolerance);
                
                return simplifiedLeft.slice(0, simplifiedLeft.length - 1).concat(simplifiedRight);
            } else {
                return [start, end];
            }
        }

        // Calculate perpendicular distance from point to line
        function perpendicularDistance(point, lineStart, lineEnd) {
            const [x, y] = point;
            const [x1, y1] = lineStart;
            const [x2, y2] = lineEnd;
            
            if (x1 === x2 && y1 === y2) {
                return Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2));
            }
            
            const area = Math.abs(0.5 * (x1 * y2 + x2 * y + x * y1 - x2 * y1 - x * y2 - x1 * y));
            const bottom = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
            return (2 * area) / bottom;
        }

        // Get elevations for coordinates using Open-Elevation API
        async function getElevations(coordinates) {
            const locations = coordinates.map(coord => ({
                latitude: coord[1],
                longitude: coord[0]
            }));
            
            // Split into chunks to avoid too many points in one request
            const chunkSize = 100;
            const chunks = [];
            for (let i = 0; i < locations.length; i += chunkSize) {
                chunks.push(locations.slice(i, i + chunkSize));
            }
            
            const allElevations = [];
            
            for (const chunk of chunks) {
                const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        locations: chunk
                    })
                });
                
                if (!response.ok) {
                    throw new Error("Failed to get elevation data");
                }
                
                const data = await response.json();
                const elevations = data.results.map(result => result.elevation);
                allElevations.push(...elevations);
            }
            
            return allElevations;
        }

        // Calculate distances between consecutive points (in meters)
        function calculateDistances(coordinates) {
            const distances = [];
            
            for (let i = 1; i < coordinates.length; i++) {
                const prev = coordinates[i - 1];
                const curr = coordinates[i];
                
                // Haversine formula for distance between two points on a sphere
                const R = 6371000; // Earth radius in meters
                const φ1 = prev[1] * Math.PI / 180;
                const φ2 = curr[1] * Math.PI / 180;
                const Δφ = (curr[1] - prev[1]) * Math.PI / 180;
                const Δλ = (curr[0] - prev[0]) * Math.PI / 180;
                
                const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                          Math.cos(φ1) * Math.cos(φ2) *
                          Math.sin(Δλ/2) * Math.sin(Δλ/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                distances.push(R * c);
            }
            
            return distances;
        }

        // Calculate cumulative distances
        function calculateCumulativeDistances(distances) {
            const cumulative = [0];
            let sum = 0;
            
            for (const dist of distances) {
                sum += dist;
                cumulative.push(sum);
            }
            
            return cumulative;
        }

        // Calculate total elevation gain
        function calculateElevationGain(elevations) {
            let gain = 0;
            
            for (let i = 1; i < elevations.length; i++) {
                const diff = elevations[i] - elevations[i - 1];
                if (diff > 0) {
                    gain += diff;
                }
            }
            
            return Math.round(gain);
        }

        // Update elevation chart
        function updateElevationChart(distances, elevations) {
            const ctx = document.getElementById('elevationChart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (elevationChart) {
                elevationChart.destroy();
            }
            
            elevationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: distances.map(d => (d / 1000).toFixed(1) + ' km'),
                    datasets: [{
                        label: 'Elevation (m)',
                        data: elevations,
                        borderColor: '#ff5722',
                        backgroundColor: 'rgba(255, 87, 34, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Distance'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Elevation (m)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Elevation: ${context.parsed.y} m`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Close elevation modal
        function closeElevationModal() {
            document.getElementById('elevationModal').style.display = 'none';
        }
        // 新增變數用於GPS追蹤
        let isTracking = false;
        let trackingInterval;
        let currentTrack = {
            name: '',
            coordinates: [],
            timestamps: [],
            elevations: []
        };
        let trackingLayer2D; // Re-declared for clarity, but already global
        let trackingLayer3D; // Re-declared for clarity, but already global
        let trackingLine;

        // 初始化追蹤圖層
        function initTrackingLayers() {
            // 2D追蹤圖層
            // `vectorLayer2D` is already initialized and handles styling based on `isTracking` property.
            // We just need to make sure the feature for tracking is added to its source.
            
            // 3D追蹤圖層（如果3D地圖已初始化）
            if (!map3d) { // Initialize map3d if it hasn't been yet, but don't display it
                // This ensures trackingLayer3D can be created even if not in 3D view
                // but if we are planning to switch to 3D later.
                // However, Cesium.Viewer call also initializes the layer itself.
                // It's better to ensure map3d is initialized via switchTo3D if it's the first time
                // or just rely on its existence if already in 3D mode.
            }
            if (!trackingLayer3D && map3d) { // Only create if map3d exists and layer not yet created
                trackingLayer3D = new Cesium.CustomDataSource('tracking');
                map3d.dataSources.add(trackingLayer3D);
            }
        }

        // 開始GPS追蹤
        function startTracking() {
            if (isTracking) return;
            
            // 提示用戶輸入路線名稱
            const routeName = prompt("Enter a name for this track:", 
                                   "Track " + new Date().toLocaleString());
            if (!routeName) return;
            
            // 初始化新路線
            currentTrack = {
                name: routeName,
                coordinates: [],
                timestamps: [],
                elevations: []
            };
            
            // 更新UI
            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'block';
            
            isTracking = true;
            
            // 清除之前的追蹤路線（如果存在）
            const source = vectorLayer2D.getSource();
            source.getFeatures().filter(f => f.get('isTracking')).forEach(f => source.removeFeature(f));

            if (trackingLayer3D) {
                trackingLayer3D.entities.removeAll();
            }
            
            // 開始獲取位置並第一次就定位
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        updateTrackPosition(position); // Update and draw first point
                        
                        // Zoom to the initial position
                        const currentLonLat = [position.coords.longitude, position.coords.latitude];
                        if (currentViewMode === '2d') {
                            map2d.getView().animate({
                                center: ol.proj.fromLonLat(currentLonLat),
                                zoom: 19, // A good zoom level for local area, but not too close
                                duration: 1000
                            });
                        } else if (currentViewMode === '3d' && map3d) {
                            map3d.camera.flyTo({
                                destination: Cesium.Cartesian3.fromDegrees(currentLonLat[0], currentLonLat[1], 1500), // Height for 3D view
                                orientation: {
                                    heading: Cesium.Math.toRadians(0),
                                    pitch: Cesium.Math.toRadians(-30),
                                    roll: 0.0
                                },
                                duration: 1
                            });
                        }

                        // Start continuous tracking after initial positioning
                        trackingInterval = setInterval(() => {
                            navigator.geolocation.getCurrentPosition(
                                position => updateTrackPosition(position),
                                error => handleTrackingError(error),
                                {
                                    enableHighAccuracy: true,
                                    maximumAge: 30000,
                                    timeout: 27000
                                }
                            );
                        }, 500); // 每5秒記錄一個點
                    },
                    error => handleTrackingError(error),
                    {
                        enableHighAccuracy: true,
                        maximumAge: 0, // Get fresh position
                        timeout: 10000
                    }
                );
            } else {
                alert("Geolocation is not supported by this browser.");
                stopTracking();
            }
        }

        // 更新追蹤位置
        function updateTrackPosition(position) {
            const coords = position.coords;
            const point = [coords.longitude, coords.latitude];
            
            // 添加到當前路線
            currentTrack.coordinates.push(point);
            currentTrack.timestamps.push(new Date(position.timestamp));
            currentTrack.elevations.push(coords.altitude || 0);
            
            // 更新地圖顯示
            updateTrackingDisplay();
        }

        // 更新追蹤顯示
        function updateTrackingDisplay() {
            if (currentTrack.coordinates.length === 0) return;
            
            // 2D地圖更新
            if (vectorLayer2D) {
                const source = vectorLayer2D.getSource();
                // Remove previous tracking feature if it exists to redraw the updated line
                source.getFeatures().filter(f => f.get('isTracking')).forEach(f => source.removeFeature(f));

                if (currentTrack.coordinates.length > 0) {
                    const lineString = new ol.geom.LineString(currentTrack.coordinates);
                    lineString.transform('EPSG:4326', 'EPSG:3857');
                    
                    const trackingFeature = new ol.Feature({
                        geometry: lineString,
                        name: currentTrack.name, // Assign name for identification
                        isTracking: true // Custom property to identify as tracking
                    });
                    source.addFeature(trackingFeature);
                }
            }
            
            // 3D地圖更新
            if (map3d && trackingLayer3D) {
                trackingLayer3D.entities.removeAll();
                
                if (currentTrack.coordinates.length > 1) {
                    const positions = Cesium.Cartesian3.fromDegreesArrayHeights(
                        currentTrack.coordinates.map((coord, i) => [coord[0], coord[1], currentTrack.elevations[i]]).flat()
                    );
                    
                    trackingLine = trackingLayer3D.entities.add({
                        id: 'currentTrackingLine', // Assign a unique ID for 3D click handling
                        polyline: {
                            positions: positions,
                            width: 5,
                            material: new Cesium.PolylineGlowMaterialProperty({
                                glowPower: 0.3,
                                color: Cesium.Color.BLUE
                            }),
                            clampToGround: true
                        }
                    });
                }
            }
        }

        // 處理追蹤錯誤
        function handleTrackingError(error) {
            console.error("Geolocation error:", error);
            if (error.code === error.PERMISSION_DENIED) {
                alert("Geolocation permission denied. Please enable location services.");
                stopTracking();
            } else if (error.code === error.POSITION_UNAVAILABLE) {
                console.log("Position unavailable, will retry...");
            } else if (error.code === error.TIMEOUT) {
                console.log("Geolocation timeout, will retry...");
            }
        }

        // 停止GPS追蹤
        function stopTracking() {
            if (!isTracking) return;
            
            clearInterval(trackingInterval);
            isTracking = false;
            
            // 更新UI
            document.getElementById('stopTrackingBtn').style.display = 'none';
            document.getElementById('startTrackingBtn').style.display = 'block';
            
            // 如果有足夠的點，詢問是否保存
            if (currentTrack.coordinates.length > 1) {
                if (confirm(`Save this track with ${currentTrack.coordinates.length} points?`)) {
                    saveCurrentTrack();
                }
            }
            
            // 生成GPX文件並提供下載
            generateGPX();

            // Clear the tracking line from the map after stopping and potential saving/downloading
            if (vectorLayer2D) {
                const source = vectorLayer2D.getSource();
                source.getFeatures().filter(f => f.get('isTracking')).forEach(f => source.removeFeature(f));
            }
            if (trackingLayer3D) {
                trackingLayer3D.entities.removeAll();
            }
        }

        // 保存當前追蹤路線
        function saveCurrentTrack() {
            if (currentTrack.coordinates.length < 2) return;
            
            const movingTime = calculateMovingTime(currentTrack.timestamps);

            // 添加到保存的路線
            savedRoutes.push({
                name: currentTrack.name,
                coordinates: currentTrack.coordinates,
                waypoints: [], // Tracking doesn't generate waypoints currently
                movingTime: movingTime // Save calculated moving time
            });
            
            // 保存到本地存儲
            saveRoutesToStorage();
            
            // 更新路線選擇器
            updateRouteSelector();
            
            // Add the saved track to the map as a regular saved route (not tracking)
            // This will redraw it with the saved route style
            addRouteToMap(currentTrack.coordinates, currentTrack.name);
        }

        // 生成GPX文件
        function generateGPX() {
            if (currentTrack.coordinates.length < 1) return;
            
            // 創建GPX文件內容
            let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="MountainMap" xmlns="http://www.topografix.com/GPX/1/1" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
    <metadata>
        <name>${currentTrack.name}</name>
        <time>${new Date().toISOString()}</time>
    </metadata>
    <trk>
        <name>${currentTrack.name}</name>
        <trkseg>`;
            
            // 添加所有追蹤點
            for (let i = 0; i < currentTrack.coordinates.length; i++) {
                const [lon, lat] = currentTrack.coordinates[i];
                const time = currentTrack.timestamps[i].toISOString();
                const ele = currentTrack.elevations[i] || 0;
                
                gpxContent += `
            <trkpt lat="${lat}" lon="${lon}">
                <ele>${ele}</ele>
                <time>${time}</time>
            </trkpt>`;
            }
            
            gpxContent += `
        </trkseg>
    </trk>
</gpx>`;
            
            // 創建下載鏈接
            const blob = new Blob([gpxContent], {type: 'application/xml'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentTrack.name.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().slice(0, 10)}.gpx`;
            document.body.appendChild(a);
            a.click();
            
            // 清理
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            init2DMap();
            // initTrackingLayers() is now called after init2DMap as it depends on map2d.
            // Also, we initialize 3D map for trackingLayer3D if needed before switching to 3D.
            // However, it's better to ensure map3d is initialized when it's supposed to be via switchTo3D.
            // So, calling initTrackingLayers here makes sense as it creates the datasource if map3d exists.
            initTrackingLayers(); 
            // Load any saved routes
            loadSavedRoutes();
            
            // Animate to Taiwan after a short delay
            setTimeout(() => {
                resetToTaiwanView();
            }, 500);
        });
    </script>
</body>
</html>
