<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D/3D Map - Taiwan with GPX and Contour Lines</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/openlayers/9.2.4/ol.css">
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.95/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1500px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 300;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .upload-button, .save-route-button, .clear-routes-button, 
        .reset-view-button, .switch-to-3d-button, .switch-to-2d-button,.tracking-button {
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-button {
            background: linear-gradient(135deg, #4fd1c5, #319795);
        }

        .save-route-button {
            background: linear-gradient(135deg, #f6ad55, #ed8936);
        }

        .clear-routes-button {
            background: linear-gradient(135deg, #f56565, #e53e3e);
        }

        .reset-view-button {
            background: linear-gradient(135deg, #9f7aea, #805ad5);
        }

        .switch-to-3d-button {
            background: linear-gradient(135deg, #4299e1, #3182ce);
        }

        .switch-to-2d-button {
            background: linear-gradient(135deg, #48bb78, #38a169);
            display: none; /* Hidden by default */
        }
        .tracking-button {
            background: linear-gradient(135deg, #4299e1, #3182ce);
        }
        .upload-button:hover, .save-route-button:hover, 
        .clear-routes-button:hover, .reset-view-button:hover,
        .switch-to-3d-button:hover, .switch-to-2d-button:hover, .tracking-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .map-container {
            height: 700px;
            position: relative;
        }

        #map2d {
            width: 100%;
            height: 100%;
        }

        #map3d {
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
        }

        .route-selector {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 1000;
            display: none;
        }

        .route-selector select {
            padding: 5px;
            border-radius: 4px;
            border: none;
            margin-left: 10px;
        }

        #fileInput {
            display: none;
        }

        /* Elevation profile modal styles */
        .elevation-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .elevation-content {
            background-color: white;
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .elevation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .elevation-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #7f8c8d;
        }

        .elevation-chart-container {
            height: 300px;
            width: 100%;
            position: relative;
        }

        .elevation-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ecf0f1;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
        }
        

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            .header-controls {
                flex-direction: column;
                width: 100%;
            }
            .upload-button, .save-route-button, 
            .clear-routes-button, .reset-view-button,
            .switch-to-3d-button, .switch-to-2d-button ,.tracking-button{
                width: 100%;
            }
            
            .elevation-content {
                width: 95%;
                padding: 10px;
            }
            
            .elevation-chart-container {
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>MOUNTAIN MAP</h1>
            <div class="header-controls">
                <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                    Upload GPX
                </button>
                <button class="save-route-button" onclick="showRouteSelector()" id="saveRouteBtn">
                    Saved Routes
                </button>
                <button class="clear-routes-button" onclick="clearAllRoutes()">
                    Clear Routes
                </button>
                <button class="reset-view-button" onclick="resetToTaiwanView()">
                    Home
                </button>
                  <button class="tracking-button" id="startTrackingBtn" onclick="startTracking()">
                Start Tracking
            </button>
            <button class="tracking-button" id="stopTrackingBtn" onclick="stopTracking()" style="display: none;">
                Stop Tracking
            </button>
                <button class="switch-to-3d-button" id="switchTo3D" onclick="switchTo3D()">
                    3D View
                </button>
                <button class="switch-to-2d-button" id="switchTo2D" onclick="switchTo2D()">
                    2D View
                </button>
                <input type="file" id="fileInput" accept=".gpx,.xml" onchange="handleGPXUpload(event)">
            </div>
        </div>

        <div class="map-container">
            <div id="map2d"></div>
            <div id="map3d"></div>
            <div class="route-selector" id="routeSelector">
                Select Route: 
                <select id="routeSelect" onchange="zoomToRoute()">
                    <option value="">-- Select a route --</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Elevation Profile Modal -->
    <div class="elevation-modal" id="elevationModal">
        <div class="elevation-content">
            <div class="elevation-header">
                <div class="elevation-title" id="elevationTitle">Elevation Profile</div>
                <button class="close-button" onclick="closeElevationModal()">&times;</button>
            </div>
            <div class="elevation-chart-container">
                <canvas id="elevationChart"></canvas>
            </div>
            <div class="elevation-stats">
                <div class="stat-item">
                    <div class="stat-label">Distance</div>
                    <div class="stat-value" id="totalDistance">0 km</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Min Elevation</div>
                    <div class="stat-value" id="minElevation">0 m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Max Elevation</div>
                    <div class="stat-value" id="maxElevation">0 m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Elevation Gain</div>
                    <div class="stat-value" id="elevationGain">0 m</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/openlayers/9.2.4/dist/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.95/Build/Cesium/Cesium.js"></script>
    <script>
        let map2d;
        let map3d;
        let vectorLayer2D;
        let savedRoutes = [];
        let routeSelect = document.getElementById('routeSelect');
        let routeSelector = document.getElementById('routeSelector');
        let contourLayer;
        let elevationChart;
        let currentElevationData = [];
        let cesiumEntities = [];
        let currentViewMode = '2d'; // '2d' or '3d'
        
        // Taiwan coordinates and view settings
        const TAIWAN_CENTER = [120.9605, 23.6978];
        const TAIWAN_ZOOM = 8;
        const TAIWAN_3D_VIEW = {
            destination: Cesium.Cartesian3.fromDegrees(120.9605, 23.6978, 2000000),
            orientation: {
                heading: 0.0,
                pitch: -Cesium.Math.PI_OVER_TWO,
                roll: 0.0
            }
        };

        // Initialize 2D Map (OpenLayers)
        function init2DMap() {
            // Create vector layer for GPX routes
            vectorLayer2D = new ol.layer.Vector({
                source: new ol.source.Vector(),
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#ff5722',
                        width: 3
                    })
                })
            });

            // Create OpenTopoMap base layer
            //const openTopoMapLayer = new ol.layer.Tile({
              //  source: new ol.source.XYZ({
                //    url: 'https://{a-c}.tile.opentopomap.org/{z}/{x}/{y}.png',
                  //  attributions: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
                //})
            //});

            // Create contour lines layer (100m interval)
            contourLayer = new ol.layer.Vector({
                source: new ol.source.Vector({
                    url: 'https://tiles.arcgis.com/tiles/nGt4QxSblgDfeJn9/arcgis/rest/services/World_Contour/VectorTileServer/tile/{z}/{y}/{x}.pbf',
                    format: new ol.format.MVT(),
                    attributions: 'Contour lines: &copy; <a href="https://www.arcgis.com/home/item.html?id=1e126e7520f9466c9ca28b8f28b5e500">Esri</a>'
                }),
                style: createContourStyle,
                minResolution: 0, // Show at all zoom levels
                maxResolution: 100 // Hide when zoomed out too far
            });

            map2d = new ol.Map({
                target: 'map2d',
                layers: [
                    //openTopoMapLayer,
                    new ol.layer.Tile({
                        source: new ol.source.OSM()
                    }),
                    contourLayer,
                    vectorLayer2D
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat(TAIWAN_CENTER),
                    zoom: TAIWAN_ZOOM
                })
            });

            // Add click event listener to the map
            map2d.on('click', function(evt) {
                // Check if a route was clicked
                map2d.forEachFeatureAtPixel(evt.pixel, function(feature) {
                    if (feature.getGeometry().getType() === 'LineString') {
                        // Get the coordinates of the clicked route
                        const coords = feature.getGeometry().getCoordinates();
                        
                        // Convert back to lon/lat
                        const lonLatCoords = coords.map(coord => ol.proj.toLonLat(coord));
                        
                        // Get elevation data and show profile
                        getElevationProfile(lonLatCoords);
                    }
                });
            });
        }

        // Initialize 3D Map (Cesium)
        function init3DMap() {
            // Your Cesium ion access token (replace with your own)
            Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzMTI4YjE3OC1iNmVlLTRmMjQtODdhYS1kN2FiMzhkZDY1MjEiLCJpZCI6Mjk1ODg3LCJpYXQiOjE3NDUyOTE1NjJ9.ss2YK3CdkwaCvtS0O-AskkrH5yf0OunQnQkYaVysuwM';
            
            // Initialize the Cesium Viewer
            map3d = new Cesium.Viewer('map3d', {
                terrainProvider: Cesium.createWorldTerrain(),
                baseLayerPicker: false,
                sceneModePicker: false,
                homeButton: false,
                geocoder: false,
                navigationHelpButton: false,
                animation: false,
                timeline: false,
                fullscreenButton: false,
                infoBox: false,
                selectionIndicator: false,
            });

            // Set initial view to Taiwan
            map3d.camera.flyTo(TAIWAN_3D_VIEW);

            // Enable lighting effects
            map3d.scene.globe.enableLighting = true;

            // Add click handler for routes
            map3d.screenSpaceEventHandler.setInputAction(function(movement) {
                const pickedObject = map3d.scene.pick(movement.position);
                if (Cesium.defined(pickedObject) && pickedObject.id && pickedObject.id.routeId !== undefined) {
                    const route = savedRoutes[pickedObject.id.routeId];
                    if (route) {
                        getElevationProfile(route.coordinates);
                    }
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }

        // Style function for contour lines
        function createContourStyle(feature) {
            const elevation = feature.get('ELEV');
            const isIndexContour = elevation % 500 === 0; // Thicker lines for 500m intervals
            
            return new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: isIndexContour ? 'rgba(0, 0, 255, 0.8)' : 'rgba(0, 0, 255, 0.5)',
                    width: isIndexContour ? 2 : 1
                })
            });
        }

        // Reset view to Taiwan
        function resetToTaiwanView() {
            if (currentViewMode === '2d' && map2d) {
                const taiwanLocation = ol.proj.fromLonLat(TAIWAN_CENTER);
                map2d.getView().animate({
                    center: taiwanLocation,
                    zoom: TAIWAN_ZOOM,
                    duration: 1000
                });
            } else if (currentViewMode === '3d' && map3d) {
                map3d.camera.flyTo(TAIWAN_3D_VIEW);
            }
        }

        // Switch to 3D view
        function switchTo3D() {
            if (currentViewMode === '3d') return;
            
            // Initialize 3D map if not already done
            if (!map3d) {
                init3DMap();
            }
            
            // Hide 2D map and show 3D map
            document.getElementById('map2d').style.display = 'none';
            document.getElementById('map3d').style.display = 'block';
            
            // Update UI buttons
            document.getElementById('switchTo3D').style.display = 'none';
            document.getElementById('switchTo2D').style.display = 'block';
            
            currentViewMode = '3d';
            
            // Add all saved routes to 3D map
            update3DRoutes();
            
            // Reset view to Taiwan
            resetToTaiwanView();
        }

        // Switch to 2D view
        function switchTo2D() {
            if (currentViewMode === '2d') return;
            
            // Hide 3D map and show 2D map
            document.getElementById('map3d').style.display = 'none';
            document.getElementById('map2d').style.display = 'block';
            
            // Update UI buttons
            document.getElementById('switchTo2D').style.display = 'none';
            document.getElementById('switchTo3D').style.display = 'block';
            
            currentViewMode = '2d';
            
            // Reset view to Taiwan
            resetToTaiwanView();
        }

        // Update 3D routes (add all saved routes to 3D map)
        function update3DRoutes() {
            if (!map3d) return;
            
            // Remove existing entities
            cesiumEntities.forEach(entity => {
                map3d.entities.remove(entity);
            });
            cesiumEntities = [];
            
            // Add all saved routes
            savedRoutes.forEach((route, index) => {
                const positions = Cesium.Cartesian3.fromDegreesArray(
                    route.coordinates.flat()
                );
                
                const routeEntity = map3d.entities.add({
                    name: route.name,
                    polyline: {
                        positions: positions,
                        width: 5,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.2,
                            color: Cesium.Color.ORANGE
                        }),
                        clampToGround: true
                    },
                    routeId: index // Custom property to identify the route
                });
                
                cesiumEntities.push(routeEntity);
            });
        }

        // Handle GPX file upload
        function handleGPXUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const gpxContent = e.target.result;
                const routeName = file.name.replace('.gpx', '').replace('.xml', '');
                
                // Parse GPX and add to saved routes
                parseGPX(gpxContent, routeName);
                
                // Save to localStorage
                saveRoutesToStorage();
                
                // Add to route selector
                updateRouteSelector();
                
                // Show the route selector if it's hidden
                routeSelector.style.display = 'block';
                
                // Zoom to the newly added route
                zoomToRoute(savedRoutes.length - 1);
            };
            reader.readAsText(file);
        }

        // Parse GPX file and add to map
        function parseGPX(gpxContent, routeName) {
            try {
                // Parse XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(gpxContent, "text/xml");
                
                // Check for parsing errors
                const parserErrors = xmlDoc.getElementsByTagName("parsererror");
                if (parserErrors.length > 0) {
                    throw new Error("Invalid GPX file format");
                }

                // Extract coordinates from GPX
                const trackPoints = xmlDoc.getElementsByTagName("trkpt");
                const coordinates = [];
                
                for (let i = 0; i < trackPoints.length; i++) {
                    const pt = trackPoints[i];
                    const lon = parseFloat(pt.getAttribute("lon"));
                    const lat = parseFloat(pt.getAttribute("lat"));
                    
                    // Skip invalid coordinates
                    if (isNaN(lon) || isNaN(lat)) continue;
                    
                    coordinates.push([lon, lat]);
                }
                
                if (coordinates.length === 0) {
                    throw new Error("No valid coordinates found in GPX file");
                }
                
                // Save route data
                const routeIndex = savedRoutes.length;
                savedRoutes.push({
                    name: routeName,
                    coordinates: coordinates
                });
                
                // Add to map
                addRouteToMap(coordinates);
                
                return true;
            } catch (error) {
                alert("Error parsing GPX file: " + error.message);
                return false;
            }
        }

        // Add route to map
        function addRouteToMap(coordinates) {
            // Add to 2D map
            const lineString = new ol.geom.LineString(coordinates);
            lineString.transform('EPSG:4326', 'EPSG:3857');
            
            const feature = new ol.Feature({
                geometry: lineString,
                name: savedRoutes[savedRoutes.length - 1].name
            });
            
            vectorLayer2D.getSource().addFeature(feature);
            
            // Add to 3D map if in 3D mode
            if (currentViewMode === '3d' && map3d) {
                update3DRoutes();
            }
        }

        // Show route selector dropdown
        function showRouteSelector() {
            if (savedRoutes.length === 0) {
                alert("No routes available. Please upload a GPX file first.");
                return;
            }
            
            routeSelector.style.display = routeSelector.style.display === 'block' ? 'none' : 'block';
        }

        // Zoom to selected route
        function zoomToRoute(index) {
            if (index === undefined) {
                index = routeSelect.value;
                if (index === "") return;
            }
            
            const route = savedRoutes[index];
            if (!route) return;
            
            if (currentViewMode === '2d') {
                // Calculate bounds for 2D map
                const extent = ol.extent.boundingExtent(
                    route.coordinates.map(coord => ol.proj.fromLonLat(coord))
                );
                
                // Add some padding
                ol.extent.scaleFromCenter(extent, 1.2);
                
                map2d.getView().fit(extent, {
                    padding: [50, 50, 50, 50],
                    duration: 1000
                });
            } else {
                // Fly to route in 3D
                const positions = Cesium.Cartesian3.fromDegreesArray(
                    route.coordinates.flat()
                );
                
                // Calculate bounding sphere
                const boundingSphere = Cesium.BoundingSphere.fromPoints(positions);
                
                // Fly to the route with some offset
                map3d.camera.flyTo({
                destination: Cesium.Cartesian3.fromElements(
                        boundingSphere.center.x*1.003,
                        boundingSphere.center.y*1.003,
                        boundingSphere.center.z*0.996),
                orientation: {
                    heading: 0.0,
                    pitch: -0.5,
                    roll: 0.0
                },
        });
            }
        }

        // Save routes to localStorage
        function saveRoutesToStorage() {
            localStorage.setItem('savedRoutes', JSON.stringify(savedRoutes));
        }

        // Load routes from localStorage
        function loadSavedRoutes() {
            const storedRoutes = localStorage.getItem('savedRoutes');
            if (storedRoutes) {
                savedRoutes = JSON.parse(storedRoutes);
                
                // Clear existing routes from map
                vectorLayer2D.getSource().clear();
                
                // Add all saved routes to map
                savedRoutes.forEach(route => {
                    addRouteToMap(route.coordinates);
                });
                
                // Update route selector
                updateRouteSelector();
                
                // Show selector if there are routes
                if (savedRoutes.length > 0) {
                    routeSelector.style.display = 'block';
                }
            }
        }

        // Update the route selector dropdown
        function updateRouteSelector() {
            // Clear existing options
            routeSelect.innerHTML = '<option value="">-- Select a route --</option>';
            
            // Add all saved routes
            savedRoutes.forEach((route, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = route.name;
                routeSelect.appendChild(option);
            });
        }

        // Clear all saved routes
        function clearAllRoutes() {
            if (savedRoutes.length === 0) {
                alert("No routes to clear.");
                return;
            }
            
            if (confirm("Are you sure you want to delete all saved routes?")) {
                // Clear from map
                vectorLayer2D.getSource().clear();
                
                // Clear from 3D map if active
                if (map3d) {
                    cesiumEntities.forEach(entity => {
                        map3d.entities.remove(entity);
                    });
                    cesiumEntities = [];
                }
                
                // Clear from memory and storage
                savedRoutes = [];
                localStorage.removeItem('savedRoutes');
                
                // Update UI
                routeSelect.innerHTML = '<option value="">-- Select a route --</option>';
                routeSelector.style.display = 'none';
            }
        }

        // Get elevation profile for a route
        async function getElevationProfile(coordinates) {
// Show loading state
document.getElementById('elevationTitle').textContent = "Loading elevation data...";
document.getElementById('totalDistance').textContent = "Calculating...";
document.getElementById('minElevation').textContent = "";
document.getElementById('maxElevation').textContent = "";
document.getElementById('elevationGain').textContent = "";

        // Open the modal
        const modal = document.getElementById('elevationModal');
        modal.style.display = 'flex';
        
        try {
            // Simplify the coordinates to reduce API calls
            const simplifiedCoords = simplifyCoordinates(coordinates, 0.0001);
            
            // Get elevations for each point
            const elevationData = await getElevations(simplifiedCoords);
            
            // Calculate distance between points
            const distances = calculateDistances(simplifiedCoords);
            
            // Calculate cumulative distance
            const cumulativeDistances = calculateCumulativeDistances(distances);
            
            // Calculate elevation gain
            const elevationGain = calculateElevationGain(elevationData);
            
            // Update the chart
            updateElevationChart(cumulativeDistances, elevationData);
            
            // Update stats
            document.getElementById('elevationTitle').textContent = "Elevation Profile";
            document.getElementById('totalDistance').textContent = (cumulativeDistances[cumulativeDistances.length - 1] / 1000).toFixed(2) + " km";
            document.getElementById('minElevation').textContent = Math.min(...elevationData) + " m";
            document.getElementById('maxElevation').textContent = Math.max(...elevationData) + " m";
            document.getElementById('elevationGain').textContent = elevationGain + " m";
            
            // Save current elevation data for chart reference
            currentElevationData = {
                distances: cumulativeDistances,
                elevations: elevationData
            };
            
        } catch (error) {
            console.error("Error getting elevation data:", error);
            document.getElementById('elevationTitle').textContent = "Error Loading Elevation Data";
            alert("Failed to load elevation data. Please try again.");
        }
    }

    // Simplify coordinates using Douglas-Peucker algorithm
    function simplifyCoordinates(coordinates, tolerance) {
        if (coordinates.length <= 2) return coordinates;
        
        // Find the point with the maximum distance
        let maxDist = 0;
        let maxIndex = 0;
        const start = coordinates[0];
        const end = coordinates[coordinates.length - 1];
        
        for (let i = 1; i < coordinates.length - 1; i++) {
            const dist = perpendicularDistance(coordinates[i], start, end);
            if (dist > maxDist) {
                maxDist = dist;
                maxIndex = i;
            }
        }
        
        // If max distance is greater than tolerance, recursively simplify
        if (maxDist > tolerance) {
            const left = coordinates.slice(0, maxIndex + 1);
            const right = coordinates.slice(maxIndex);
            
            const simplifiedLeft = simplifyCoordinates(left, tolerance);
            const simplifiedRight = simplifyCoordinates(right, tolerance);
            
            return simplifiedLeft.slice(0, simplifiedLeft.length - 1).concat(simplifiedRight);
        } else {
            return [start, end];
        }
    }

    // Calculate perpendicular distance from point to line
    function perpendicularDistance(point, lineStart, lineEnd) {
        const [x, y] = point;
        const [x1, y1] = lineStart;
        const [x2, y2] = lineEnd;
        
        if (x1 === x2 && y1 === y2) {
            return Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2));
        }
        
        const area = Math.abs(0.5 * (x1 * y2 + x2 * y + x * y1 - x2 * y1 - x * y2 - x1 * y));
        const bottom = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        return (2 * area) / bottom;
    }

    // Get elevations for coordinates using OpenTopoMap API
    async function getElevations(coordinates) {
        // OpenTopoMap doesn't have a direct elevation API, so we'll use Open-Elevation API
        const locations = coordinates.map(coord => ({
            latitude: coord[1],
            longitude: coord[0]
        }));
        
        // Split into chunks to avoid too many points in one request
        const chunkSize = 100;
        const chunks = [];
        for (let i = 0; i < locations.length; i += chunkSize) {
            chunks.push(locations.slice(i, i + chunkSize));
        }
        
        const allElevations = [];
        
        for (const chunk of chunks) {
            const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    locations: chunk
                })
            });
            
            if (!response.ok) {
                throw new Error("Failed to get elevation data");
            }
            
            const data = await response.json();
            const elevations = data.results.map(result => result.elevation);
            allElevations.push(...elevations);
        }
        
        return allElevations;
    }

    // Calculate distances between consecutive points (in meters)
    function calculateDistances(coordinates) {
        const distances = [];
        
        for (let i = 1; i < coordinates.length; i++) {
            const prev = coordinates[i - 1];
            const curr = coordinates[i];
            
            // Haversine formula for distance between two points on a sphere
            const R = 6371000; // Earth radius in meters
            const φ1 = prev[1] * Math.PI / 180;
            const φ2 = curr[1] * Math.PI / 180;
            const Δφ = (curr[1] - prev[1]) * Math.PI / 180;
            const Δλ = (curr[0] - prev[0]) * Math.PI / 180;
            
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            distances.push(R * c);
        }
        
        return distances;
    }

    // Calculate cumulative distances
    function calculateCumulativeDistances(distances) {
        const cumulative = [0];
        let sum = 0;
        
        for (const dist of distances) {
            sum += dist;
            cumulative.push(sum);
        }
        
        return cumulative;
    }

    // Calculate total elevation gain
    function calculateElevationGain(elevations) {
        let gain = 0;
        
        for (let i = 1; i < elevations.length; i++) {
            const diff = elevations[i] - elevations[i - 1];
            if (diff > 0) {
                gain += diff;
            }
        }
        
        return Math.round(gain);
    }

    // Update elevation chart
    function updateElevationChart(distances, elevations) {
        const ctx = document.getElementById('elevationChart').getContext('2d');
        
        // Destroy previous chart if it exists
        if (elevationChart) {
            elevationChart.destroy();
        }
        
        elevationChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: distances.map(d => (d / 1000).toFixed(1) + ' km'),
                datasets: [{
                    label: 'Elevation (m)',
                    data: elevations,
                    borderColor: '#ff5722',
                    backgroundColor: 'rgba(255, 87, 34, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Distance'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Elevation (m)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Elevation: ${context.parsed.y} m`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Close elevation modal
    function closeElevationModal() {
        document.getElementById('elevationModal').style.display = 'none';
    }
    // 新增變數用於GPS追蹤
let isTracking = false;
let trackingInterval;
let currentTrack = {
    name: '',
    coordinates: [],
    timestamps: [],
    elevations: []
};
let trackingLayer2D;
let trackingLayer3D;
let trackingLine;

// 初始化追蹤圖層
function initTrackingLayers() {
    // 2D追蹤圖層
    trackingLayer2D = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: '#4299e1',
                width: 4,
                lineDash: [10, 5]
            })
        })
    });
    map2d.addLayer(trackingLayer2D);
    
    // 3D追蹤圖層（如果3D地圖已初始化）
    if (map3d) {
        trackingLayer3D = new Cesium.CustomDataSource('tracking');
        map3d.dataSources.add(trackingLayer3D);
    }
}

// 開始GPS追蹤
function startTracking() {
    if (isTracking) return;
    
    // 提示用戶輸入路線名稱
    const routeName = prompt("Enter a name for this track:", 
                           "Track " + new Date().toLocaleString());
    if (!routeName) return;
    
    // 初始化新路線
    currentTrack = {
        name: routeName,
        coordinates: [],
        timestamps: [],
        elevations: []
    };
    
    // 更新UI
    document.getElementById('startTrackingBtn').style.display = 'none';
    document.getElementById('stopTrackingBtn').style.display = 'block';
    
    isTracking = true;
    
    // 清除之前的追蹤路線
    if (trackingLayer2D) {
        trackingLayer2D.getSource().clear();
    }
    if (trackingLayer3D) {
        trackingLayer3D.entities.removeAll();
    }
    
    // 開始獲取位置
    if (navigator.geolocation) {
        // 先立即獲取一次位置並移動到該位置
        navigator.geolocation.getCurrentPosition(
            position => {
                // 移動到當前位置
                moveToCurrentPosition(position);
                // 然後開始定期追蹤
                trackingInterval = setInterval(() => {
                    navigator.geolocation.getCurrentPosition(
                        position => updateTrackPosition(position),
                        error => handleTrackingError(error),
                        {
                            enableHighAccuracy: true,
                            maximumAge: 30000,
                            timeout: 27000
                        }
                    );
                }, 500); // 每5秒記錄一個點
            },
            error => handleTrackingError(error),
            {
                enableHighAccuracy: true,
                maximumAge: 30000,
                timeout: 27000
            }
        );
    } else {
        alert("Geolocation is not supported by this browser.");
        stopTracking();
    }
}
// 新增函數：移動到當前位置
function moveToCurrentPosition(position) {
    const coords = position.coords;
    const point = [coords.longitude, coords.latitude];
    
    if (currentViewMode === '2d' && map2d) {
        // 2D地圖移動到當前位置
        const view = map2d.getView();
        view.animate({
            center: ol.proj.fromLonLat(point),
            zoom: 16, // 較高的縮放級別
            duration: 500 // 快速移動
        });
    } else if (currentViewMode === '3d' && map3d) {
        // 3D地圖移動到當前位置
        map3d.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(
                coords.longitude, 
                coords.latitude, 
                coords.altitude ? coords.altitude + 100 : 500), // 高度稍高於當前位置
            orientation: {
                heading: 0.0,
                pitch: -0.5, // 稍微傾斜的視角
                roll: 0.0
            },
            duration: 0.5 // 快速移動
        });
    }}
// 更新追蹤位置
function updateTrackPosition(position) {
    const coords = position.coords;
    const point = [coords.longitude, coords.latitude];
    
    // 添加到當前路線
    currentTrack.coordinates.push(point);
    currentTrack.timestamps.push(new Date(position.timestamp));
    currentTrack.elevations.push(coords.altitude || 0);
    
    // 更新地圖顯示
    updateTrackingDisplay();
}

// 更新追蹤顯示
function updateTrackingDisplay() {
    if (currentTrack.coordinates.length === 0) return;
    
    // 2D地圖更新
    if (currentViewMode === '2d' && trackingLayer2D) {
        const lineString = new ol.geom.LineString(currentTrack.coordinates);
        lineString.transform('EPSG:4326', 'EPSG:3857');
        
        trackingLayer2D.getSource().clear();
        trackingLayer2D.getSource().addFeature(new ol.Feature({
            geometry: lineString
        }));
    }
    
    // 3D地圖更新
    if (currentViewMode === '3d' && trackingLayer3D) {
        trackingLayer3D.entities.removeAll();
        
        if (currentTrack.coordinates.length > 1) {
            const positions = Cesium.Cartesian3.fromDegreesArray(
                currentTrack.coordinates.flat()
            );
            
            trackingLine = trackingLayer3D.entities.add({
                polyline: {
                    positions: positions,
                    width: 5,
                    material: new Cesium.PolylineGlowMaterialProperty({
                        glowPower: 0.3,
                        color: Cesium.Color.BLUE
                    }),
                    clampToGround: true
                }
            });
        }
    }
}

// 處理追蹤錯誤
function handleTrackingError(error) {
    console.error("Geolocation error:", error);
    if (error.code === error.PERMISSION_DENIED) {
        alert("Geolocation permission denied. Please enable location services.");
        stopTracking();
    } else if (error.code === error.POSITION_UNAVAILABLE) {
        console.log("Position unavailable, will retry...");
    } else if (error.code === error.TIMEOUT) {
        console.log("Geolocation timeout, will retry...");
    }
}

// 停止GPS追蹤
function stopTracking() {
    if (!isTracking) return;
    
    clearInterval(trackingInterval);
    isTracking = false;
    
    // 更新UI
    document.getElementById('stopTrackingBtn').style.display = 'none';
    document.getElementById('startTrackingBtn').style.display = 'block';
    
    // 如果有足夠的點，詢問是否保存
    if (currentTrack.coordinates.length > 1) {
        if (confirm(`Save this track with ${currentTrack.coordinates.length} points?`)) {
            saveCurrentTrack();
        }
    }
    
    // 生成GPX文件並提供下載
    generateGPX();
}

// 保存當前追蹤路線
function saveCurrentTrack() {
    if (currentTrack.coordinates.length < 2) return;
    
    // 添加到保存的路線
    savedRoutes.push({
        name: currentTrack.name,
        coordinates: currentTrack.coordinates
    });
    
    // 保存到本地存儲
    saveRoutesToStorage();
    
    // 更新路線選擇器
    updateRouteSelector();
    
    // 添加到地圖
    addRouteToMap(currentTrack.coordinates);
}

// 生成GPX文件
function generateGPX() {
    if (currentTrack.coordinates.length < 1) return;
    
    // 創建GPX文件內容
    let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="MountainMap" xmlns="http://www.topografix.com/GPX/1/1" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
    <metadata>
        <name>${currentTrack.name}</name>
        <time>${new Date().toISOString()}</time>
    </metadata>
    <trk>
        <name>${currentTrack.name}</name>
        <trkseg>`;
    
    // 添加所有追蹤點
    for (let i = 0; i < currentTrack.coordinates.length; i++) {
        const [lon, lat] = currentTrack.coordinates[i];
        const time = currentTrack.timestamps[i].toISOString();
        const ele = currentTrack.elevations[i] || 0;
        
        gpxContent += `
            <trkpt lat="${lat}" lon="${lon}">
                <ele>${ele}</ele>
                <time>${time}</time>
            </trkpt>`;
    }
    
    gpxContent += `
        </trkseg>
    </trk>
</gpx>`;
    
    // 創建下載鏈接
    const blob = new Blob([gpxContent], {type: 'application/xml'});
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${currentTrack.name.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().slice(0, 10)}.gpx`;
    document.body.appendChild(a);
    a.click();
    
    // 清理
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 100);
}
    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
        init2DMap();
        initTrackingLayers();
        // Load any saved routes
        loadSavedRoutes();
        
        // Animate to Taiwan after a short delay
        setTimeout(() => {
            resetToTaiwanView();
        }, 500);
    });
</script>
